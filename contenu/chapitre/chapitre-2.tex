\chapter{Implémentations et sélection de niveaux de fréquences}
\label{chap:chapitre2}

Notre recherche est une étude exploratoire du modèle multi-résolutionnel local, en particulier de la congruence de phase, issu du traitement d'images, appliquée dans le contexte de la synthèse de texture. Nous allons maintenant voir la mise en application des concepts exposés à la partie précédente, ainsi que les résultats obtenus.

\section{Mise en application}

Les concepts d'énergie locale et de signal monogène ne sont pas des notions communément utilisées dans le traitement d'images, aucune librairie standard ne les implémente à notre connaissance. Nous avons donc dû implémenter nous-même les algorithmes pour mettre en place le modèle multi-résolutionnel local. Le choix du logiciel pour faire ces implémentations a été une question importante.


%\subsection{OpenCV}
\paragraph{OpenCV}

Malgré notre but final de travailler sur de la synthèse de texture, nous avons commencé par développer un petit logiciel pour pouvoir itérer rapidement et expérimenter avec les concepts de base du modèle multi-résolutionnel local sur des images, sans prendre en compte les problématiques de la synthèse. Pour cela, nous mis au point un logiciel utilisant \cpp avec la librairie OpenCV~\cite{opencv_library}. OpenCV est une librairie standard de traitement d'images en temps réel et de vision par ordinateur, disponible pour les langages de programmation \cpp, Python et Java. Les images y sont représentées comme des matrices, et les opérations de bas niveau courantes du traitement d'images y sont implémentées, comme la lecture, l'écriture, l'affichage, le filtrage, la convolution, et autres.  Notre logiciel permet à un utilisateur de créer, visualiser, et modifier les pyramides d'une image d'entrée, ainsi que de calculer et visualiser la congruence de phase. Avec ces fonctionnalités, nous avons fait des expérimentations pour voir l'effet de différentes modifications et reconstructions de la pyramide de Riesz d'une image.


\bigskip

Plusieurs raisons ont ensuite motivé notre choix de changer d'implémentation. Après avoir expérimenté avec la congruence de phases sur des images, nous voulions travailler avec des textures, c'est à dire faire de la synthèse dans le cadre du pipeline graphique traditionnel. Plus que simplement reconstruire une image, nous voulions maintenant synthétiser une texture à projeter sur une surface, potentiellement infinie, dans le but de la recouvrir. Dans un tel contexte, plusieurs problématiques surviennent. La synthèse de texture doit pouvoir se faire dans le fragment shader, depuis le GPU, pour être mise en place dans le pipeline graphique. Cela veut dire avoir une méthode de reconstruction parallélisable, ce qui n'est pas le cas de la méthode que nous utilisions jusque là. Se posent aussi des questions de projection et de filtrage, que n'avions pas eu à traiter jusque là, mais nécessaires à considérer pour de la synthèse de textures.

Parallèlement, notre laboratoire de recherche a accueilli de nouveaux membres, qui travaillaient sur des problématiques similaires aux nôtres. Nous voulions alors mettre en place un logiciel qui servirait de base de travail commune pour les personnes faisant de la synthèse de textures dans le laboratoire. Nous avons considéré plusieurs options, notamment développer un moteur de rendu personnalisé et adapté à nos besoins, ou utiliser un des moteurs de jeu Unity3D~\cite{unity_engine} ou Unreal Engine~\cite{unreal_engine}. Le problème d'un moteur personnalisé est qu'il nous aurait fallu réimplémenter beaucoup de choses nous-même, ce qui aurait été long et redondant. Les moteurs Unity3D et Unreal Engine, eux, avaient le désavantage de ne pas offrir la flexibilité de manipuler les textures tel que nous souhaitions le faire. Nous avons donc choisi une autre option, le moteur de jeu Godot~\cite{godot_game_engine}.

\paragraph{Godot}

Godot est un logiciel libre et gratuit, moteur de jeu 2D et 3D, qui permet de faire du rendu temps-réel et donc de s'intéresser aux problématiques de la synthèse de texture, ce que ne permettait pas OpenCV. Bien que pour l'instant moins populaire que Unity et Unreal Engine, Godot est une solution qui croit en notoriété, surtout dans la recherche en informatique graphique, car il est léger et flexible, et permet facilement d'écrire des modules personnalisés ou de modifier du code source pour s'adapter aux besoins des utilisateurs. C'est ce que nous avons fait avec Nicolas Lutz, post-doctorant du laboratoire. Nous avons travaillé conjointement à développer \textit{TexSyn}, une librairie \cpp de traitement d'images et de synthèse de texture pour Godot.

Godot a une classe qui gère les textures, mais la manipuler est compliqué et peu efficace pour des opérations d'accès direct dont nous avons besoin pour nos synthèses. Notre librairie \textit{TexSyn} définit donc une classe d'image plus pratique à utiliser, avec toutes les opérations dont nous avons besoin, qui est ensuite interfacée avec la classe d'image de Godot pour être utilisée depuis l'éditeur. On construit SY avec cela nos pyramides en pré-calcul sur le CPU, que l'on stocke dans des atlas de textures, qui sont ensuite chargés sur le GPU. On fait alors la reconstruction depuis nos shaders, en temps réel, en utilisant les pyramides stockées dans les atlas. Cette reconstruction a cependant des problèmes de filtrage, car nous ne pouvons pas appliquer de convolution avec un filtre pour faire un lissage depuis le fragment shader. Nous avons ensuite travaillé à développer une méthode de synthèse pouvant traiter des textures à structure irrégulière, en mettant au point un échantillonneur préservant la congruence de phases, détaillé plus loin dans ce chapitre.

\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{contenu/resources/images/reconstruction_cpu_vs_gpu}
    \caption[Reconstruction de texture dans \textit{TexSyn}]{Reconstruction de la pyramide de Riesz d'une texture, hors-ligne depuis le CPU (gauche) et en temps-réel depuis le fragment shader (droite). On remarque les artefacts de filtrage sur la reconstruction en temps-réel)}
    \label{fig:texsyn-reconstruction}
\end{figure}


\section{Sélection de niveaux de fréquences et applications}

La mise au point de la congruence de phases et l'utilisation d'un contexte multi-résolutionnel nous ont permis de visualiser explicitement que les différents niveaux de structure que l'on trouve dans une image sont liés à différents niveaux de d'échelle. Nous avons émis l'hypothèse que chaque niveau de structure que l'on distingue dans une image peut s'exprimer comme la congruence en phases d'un sous-ensemble fréquentiel. Autrement dit, chaque échelle de structure est créée par un sous-ensemble de niveaux de la pyramide d'image. Pour vérifier cela, nous avons regardé quel était le résultat de sélectionner seulement certains sous-ensembles de niveaux de la pyramide et de calculer la congruence de phases sur ces niveaux.

\begin{equation}
    PC_{\mathcal{S}}(\mathbf{x}) = \frac{W(x)E(\mathbf{x})}{\epsilon + \sum_{n\in\mathcal{S}} A_{n}(\mathbf{x})},
\end{equation}

où $\mathcal{S}$ est un sous-ensemble de niveaux de la pyramide. En pratique, nous avons essayé avec tous les $\mathcal{S} = \llbracket a, b\rrbracket$ avec $1 \leq a \leq b \leq d$. Cela nous a permit de confirmer que les différents niveaux de structure étaient bien causés par différents sous-ensembles fréquentiels, comme montré à la figure~\ref{fig:pc-selection-niveaux}.

\begin{figure}
    \centering
    \begin{subfigure}[b]{.25\textwidth}
        \centering
        \includegraphics[width=\textwidth]{contenu/resources/images/fingerprint}
        \caption{Image originale}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.25\textwidth}
        \centering
        \includegraphics[width=\textwidth]{contenu/resources/images/pc_layer_0_1}
        \caption{Niveaux 0 et 1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.25\textwidth}
        \centering
        \includegraphics[width=\textwidth]{contenu/resources/images/pc_layer_2_depth-1}
        \caption{Niveaux 2 à $d-1$}
    \end{subfigure}

    \caption[Congruence de phases sur différents niveaux d'échelle]{Congruence de phases sur différents niveaux d'échelle. Conformément à notre intuition, on observe que sur les premiers niveaux (milieu), qui correspondent aux hautes fréquences, les détails fins ressortent, tandis que sur les derniers niveaux (droite), qui correspondent aux plus basses fréquences, c'est la structure globale qui apparait.}
    \label{fig:pc-selection-niveaux}
\end{figure}


\subsection{Filtrage de bande de basse fréquence}

Suite à cette observation, nous avons mis en place une méthode de sélection de niveaux de fréquences, pour pouvoir supprimer certains niveaux de la pyramide et observer l'effet sur la reconstruction.

\subsection{Application à l'échange de contenu de PC variable}

\section{Synthèse de texture préservant la congruence de phase}

\subsection{Synthèse par ré-organisation}

- implémentation de technique classique de synthèse de texture, le HPN + phasor noise


\subsection{Échantillonneur préservant la congruence de phase}

- PC preserving sampler
-> quantization
-> stochasrtic mean
-> image partition